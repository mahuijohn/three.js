<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - cloth simulation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #000;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            padding: 10px;
            width: 100%;
            text-align: center;
        }

        a {
            text-decoration: underline;
            cursor: pointer;
        }

    </style>
</head>

<body>
<!--<div id="info">Simple Cloth Simulation<br/>-->
<!--Verlet integration with relaxed constraints<br/>-->
<!--<a onclick="wind = !wind;">Wind</a> |-->
<!--<a onclick="sphere.visible = !sphere.visible;">Ball</a> |-->
<!--<a onclick="togglePins();">Pins</a>-->
<!--</div>-->

<script src="../build/three.js"></script>

<script src="js/Detector.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/libs/stats.min.js"></script>

<script src="js/Cloth.js"></script>

<script>

    /* testing cloth simulation */

    var pinsFormation = [];
    var pins = [ 6 ];

    pinsFormation.push( pins );

    pins = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
    pinsFormation.push( pins );

    pins = [ 0 ];
    pinsFormation.push( pins );

    pins = []; // cut the rope ;)
    pinsFormation.push( pins );

    pins = [ 0, cloth.w ]; // classic 2 pins
    pinsFormation.push( pins );

    pins = pinsFormation[ 1 ];


    function togglePins() {

        pins = pinsFormation[ ~~ ( Math.random() * pinsFormation.length ) ];

    }

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    var container, stats;
    var camera, scene, renderer;

    var clothGeometry;
    var sphere;
    var object;

    init();
    animate();

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        // scene

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xcce0ff );
        scene.fog = new THREE.Fog( 0xcce0ff, 500, 10000 );

        // camera

        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.set( 1000, 50, 1500 );

        // lights

        var light, materials;

        scene.add( new THREE.AmbientLight( 0x666666 ) );

        light = new THREE.DirectionalLight( 0xdfebff, 1 );
        light.position.set( 50, 200, 100 );
        light.position.multiplyScalar( 1.3 );

        light.castShadow = true;

        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;

        var d = 300;

        light.shadow.camera.left = - d;
        light.shadow.camera.right = d;
        light.shadow.camera.top = d;
        light.shadow.camera.bottom = - d;

        light.shadow.camera.far = 1000;

        scene.add( light );

        // cloth material

//				var loader = new THREE.TextureLoader();
//				var clothTexture = loader.load( 'textures/patterns/circuit_pattern.png' );
//				clothTexture.anisotropy = 16;
//
//				var clothMaterial = new THREE.MeshLambertMaterial( {
//					map: clothTexture,
//					side: THREE.DoubleSide,
//					alphaTest: 0.5
//				} );

        // cloth geometry

//				clothGeometry = new THREE.ParametricGeometry( clothFunction, cloth.w, cloth.h );

        // cloth mesh

//				object = new THREE.Mesh( clothGeometry, clothMaterial );
//				object.position.set( 0, 0, 0 );
//				object.castShadow = true;
//				scene.add( object );
//
//				object.customDepthMaterial = new THREE.MeshDepthMaterial( {
//
//					depthPacking: THREE.RGBADepthPacking,
//					map: clothTexture,
//					alphaTest: 0.5
//
//				} );


        var wareArr = [];

        // 框架
        var material = new THREE.LineBasicMaterial({ color: 0x0000ff });
        var height = 500;


        // 仓库地形
        var geometryArea = new THREE.CubeGeometry( 300, 10, 300 );
        var materialArea = new THREE.MeshNormalMaterial( {  overdraw: 0.5 } );
        var cubeArea = new THREE.Mesh( geometryArea, materialArea );
        cubeArea.scale.y = Math.floor(1);
        cubeArea.position.x = -800 + 25;
        cubeArea.position.y = 5;
        cubeArea.position.z = 300;
        scene.add( cubeArea );


        var geometry = new THREE.Geometry();
        for (var i = 0; i < 40; i ++) {
            var pos = 50 * i - 500;

            // 过道地板
            if (i % 4 == 0 || (i + 1) % 4 == 0) {
                if ((i + 1) % 4 == 0) {
                    var geometryArea = new THREE.CubeGeometry( 100, 10, 1000 );
                    var materialArea = new THREE.MeshNormalMaterial( {  overdraw: 0.5 } );
                    var cubeArea = new THREE.Mesh( geometryArea, materialArea );
                    cubeArea.scale.y = Math.floor(1);
                    cubeArea.position.x = pos + 25;
                    cubeArea.position.y = 5;
                    cubeArea.position.z = 0;
                    scene.add( cubeArea );
                }
                continue
            }

            // 货架框架
            geometry.vertices.push(new THREE.Vector3(pos, 0, -500));
            geometry.vertices.push(new THREE.Vector3(pos, height, -500));
            geometry.vertices.push(new THREE.Vector3(pos, height, 500));
            geometry.vertices.push(new THREE.Vector3(pos, 0, 500));
            geometry.vertices.push(new THREE.Vector3(pos, 0, -500));
            var line = new THREE.Line(geometry, material);
            scene.add(line);

            for (var j = 0; j <= 10; j ++) {
                var wid = 100 * j - 500;
                // 货架分栏
                var geometryJ = new THREE.Geometry();
                geometryJ.vertices.push(new THREE.Vector3(pos, 0, wid));
                geometryJ.vertices.push(new THREE.Vector3(pos, 500, wid));
                var line = new THREE.Line(geometryJ, material);
                scene.add(line);
            }

            for (var j = 0; j <= 5; j ++) {
                var hei = 100 * j;
                // 货架分层
                var geometryJ = new THREE.Geometry();
                geometryJ.vertices.push(new THREE.Vector3(pos, hei, 500));
                geometryJ.vertices.push(new THREE.Vector3(pos, hei, -500));
                var line = new THREE.Line(geometryJ, material);
                scene.add(line);
                // 货架分栏


                if ((i - 1) % 4 == 0) {
                    for (var k = 0; k <= 10; k ++) {
                        var wid = 100 * k - 500;
                        // 完整货架框
                        var geometryK = new THREE.Geometry();
                        geometryK.vertices.push(new THREE.Vector3(pos, hei, wid));
                        geometryK.vertices.push(new THREE.Vector3(pos +  50, hei, wid));
                        var line = new THREE.Line(geometryK, material);
                        scene.add(line);
                        if (j != 5 && k != 10) {
                            wareArr.push({len: pos, hei: hei, wid: wid});
                        }
                    }
                }
            }
        }

        // 填充物

        var geometry = new THREE.CubeGeometry( 40, 80, 80 );
        var material = new THREE.MeshNormalMaterial( { overdraw: 0.5 } );
        for (var i = 0; i < wareArr.length; i ++) {
            if (Math.random() > 0.5) {
                continue
            }
            var cube = new THREE.Mesh( geometry, material );
            cube.scale.y = Math.floor(1);
            cube.position.x = wareArr[i].len + 25;
            cube.position.y = wareArr[i].hei + 50;
            cube.position.z = wareArr[i].wid + 50;
            scene.add( cube );
        }

        // sphere

//				var ballGeo = new THREE.SphereBufferGeometry( ballSize, 32, 16 );
//				var ballMaterial = new THREE.MeshLambertMaterial();
//
//				sphere = new THREE.Mesh( ballGeo, ballMaterial );
//				sphere.castShadow = true;
//				sphere.receiveShadow = true;
//				scene.add( sphere );

        // ground

//				var groundTexture = loader.load( 'textures/terrain/grasslight-big.jpg' );
//				groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
//				groundTexture.repeat.set( 25, 25 );
//				groundTexture.anisotropy = 16;
//
//				var groundMaterial = new THREE.MeshLambertMaterial( { map: groundTexture } );
//
//				var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 20000, 20000 ), groundMaterial );
//				mesh.position.y = - 250;
//				mesh.rotation.x = - Math.PI / 2;
//				mesh.receiveShadow = true;
//				scene.add( mesh );

        // poles

//				var poleGeo = new THREE.BoxBufferGeometry( 5, 375, 5 );
//				var poleMat = new THREE.MeshLambertMaterial();
//
//				var mesh = new THREE.Mesh( poleGeo, poleMat );
//				mesh.position.x = - 125;
//				mesh.position.y = - 62;
//				mesh.receiveShadow = true;
//				mesh.castShadow = true;
//				scene.add( mesh );
//
//				var mesh = new THREE.Mesh( poleGeo, poleMat );
//				mesh.position.x = 125;
//				mesh.position.y = - 62;
//				mesh.receiveShadow = true;
//				mesh.castShadow = true;
//				scene.add( mesh );
//
//				var mesh = new THREE.Mesh( new THREE.BoxBufferGeometry( 255, 5, 5 ), poleMat );
//				mesh.position.y = - 250 + ( 750 / 2 );
//				mesh.position.x = 0;
//				mesh.receiveShadow = true;
//				mesh.castShadow = true;
//				scene.add( mesh );
//
//				var gg = new THREE.BoxBufferGeometry( 10, 10, 10 );
//				var mesh = new THREE.Mesh( gg, poleMat );
//				mesh.position.y = - 250;
//				mesh.position.x = 125;
//				mesh.receiveShadow = true;
//				mesh.castShadow = true;
//				scene.add( mesh );
//
//				var mesh = new THREE.Mesh( gg, poleMat );
//				mesh.position.y = - 250;
//				mesh.position.x = - 125;
//				mesh.receiveShadow = true;
//				mesh.castShadow = true;
//				scene.add( mesh );

        // renderer

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.renderSingleSided = false;

        container.appendChild( renderer.domElement );

        renderer.gammaInput = true;
        renderer.gammaOutput = true;

        renderer.shadowMap.enabled = true;

        // controls
        var controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.maxPolarAngle = Math.PI * 1;
        controls.minDistance = 1000;
        controls.maxDistance = 5000;

        // performance monitor

        stats = new Stats();
        container.appendChild( stats.dom );

        //

        window.addEventListener( 'resize', onWindowResize, false );

//				sphere.visible = ! true;

    }

    //

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    //

    function animate() {

        requestAnimationFrame( animate );

//				var time = Date.now();
//
//				var windStrength = Math.cos( time / 7000 ) * 20 + 40;
//
//				windForce.set( Math.sin( time / 2000 ), Math.cos( time / 3000 ), Math.sin( time / 1000 ) )
//				windForce.normalize()
//				windForce.multiplyScalar( windStrength );
//
//				simulate( time );
        render();
        stats.update();

    }

    function render() {

//				var p = cloth.particles;
//
//				for ( var i = 0, il = p.length; i < il; i ++ ) {
//
//					clothGeometry.vertices[ i ].copy( p[ i ].position );
//
//				}
//
//				clothGeometry.verticesNeedUpdate = true;
//
//				clothGeometry.computeFaceNormals();
//				clothGeometry.computeVertexNormals();
//
//				sphere.position.copy( ballPosition );

        renderer.render( scene, camera );

    }

</script>
</body>
</html>
